## DOM编程

用脚本进行 DOM 操作的代价很昂贵，它是**富web** 应用中最常见的性能瓶颈



### 浏览器中的DOM

**文档对象模型（DOM）**是一个独立于语言的，用于操作 XML 和 HTML 文档的程序接口（API）

- 在浏览器中，主要用来与 HTML 文档打交道，同样页用在 Web 程序中获取 XML 文档，并使用 DOM API 用来访问文档中的数据。
- DOM 在浏览器中的接口是通过 JavaScript 实现的
- 浏览器通常会把 DOM 和 JavaScript 独立实现
  - 这个分离允许其他技术和语言能共享 DOM 以及 Trident 提供的渲染函数



#### 天生就慢

- DOM 和 JavaScript 是两个独立的模块

- 两个相互独立的功能只能通过接口彼此链接，就会产生消耗
- 尽可能减少访问 DOM 的次数，来提高性能



### DOM 访问和修改

- 访问 DOM 元素是有代价的，**修改元素的代价更高**
- 减少访问 DOM 的次数，把运算尽量留在 JavaScript 这一端处理



#### innerHTML 对比 DOM 方法

- 两者性能相差无几
- 如果在一个对性能有着苛刻要求的操作中更新一大段 HTML ，推荐使用 innerHTML



#### 节点克隆

在大多数浏览器中 克隆已有元素比创建新元素更快



#### HTML 集合

HTML 集合是包含了 DOM 节点引用的 **类数组对象**

- HTML 集合一直于文档保持着链接，每次需要最新的信息，都会重复执行查询的过程，这正是低效之源。

- 把集合的长度缓存到一个局部变量中，然后在循环的条件退出中使用该变量

- 需要多次访问同一个 DOM 属性或方法 最好使用一个局部变量缓存此成员

  - 当遍历一个集合时，第一优化原则是把：

    1. 集合存储在局部变量中，
    2. 并把 length 缓存在循环外部
    3. 使用局部变量替代这些需要多次读取的元素

    

#### 遍历DOM

DOM API提供了多种方法来读取文档结构中的特定部分。当你需要从多种方案中选择时，最好为特定操作选择最高效的API

##### 获取DOM

- 使用 childNodes 得到元素集合，使用 nextSibling 获取相邻元素
- childNodes 是个元素集合，注意缓存 length 属性

##### 元素节点

DOM 元素诸如 chilNodes，firstChild 和 nextSibling vi那个不区分元素节点和其他类型节点。在某些情况下，只需访问元素节点，因此循环中很可能需要检查返回节点的类型并过滤掉非元素节点。这些是不必要的 DOM操作。大部分现代浏览器提供 API 只返回元素节点，如果可以的话推荐使用这些 API

| 属性名                | 被替代的属性      |
| --------------------- | ----------------- |
| children              | childNodes        |
| childElementCount     | childNodes.length |
| firstElementChild     | firstChild        |
| lastElementChild      | lastChild         |
| nextElementSibling    | nextSibling       |
| previosElementSibling | previosSibling    |

##### 选择器API

使用 **document.querySelectorAll结合 css 选择器** 替代 doucument.getElementBy*



### 重绘与重排

浏览器在下载完页面中的所有组件 —— HTML标记、JavaScript、CSS、图片 —— 之后会解析并生成两个内部数据结构：

**DOM树**：表示页面结构

**渲染树**：表示 DOM 节点如何显示

- DOM 树中的每一个**需要**显示的节点在**渲染树**中至少存在一个对应的节点（隐藏的 DOM 元素中没有对应的节点）
- 渲染树中节点被称为**帧（frames）**或**盒（boxes）**
  - 符合 CSS 模型，
  - 理解页面元素为一个具有内边距（padding），外边距（margins），边框（borders）和位置（position）的盒子
- 一旦 DOM 和 渲染树构建完成，浏览器就开始显示（绘制“paint”）页面元素
- 当 DOM 的变化影响了元素的几何形状（宽和高），浏览器需要重新计算元素的几何属性，同样其他元素的几何属性和位置也会因此受影响。浏览器会使渲染树中受影响的部分失效，并重新构建渲染树。这个过程称为**重排（reflow）**。完成重排后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为**重绘（repaint）**
  - 并不是所有的 DOM 变化都会影响几何属性，列如改变元素的背景色，只会发生一次重绘（不需要重排）
  - 重排一定会导致重绘
  - 重排和重绘都是代价昂过的操作

#### 重排何时发生

- 添加或删除可见的 DOM
- 元素位置改变
- 元素尺寸改变（内外边距、边框厚度、宽高等属性）
- 内容改变（文本改变，图片被替换成另一个尺寸的图片）
- 页面渲染器初始化
- 浏览器窗口尺寸改变

#### 渲染树变化的排队与刷新

由于每次**重排**都会产生计算消耗，大多数浏览器通过**队列化**修改并批量执行来优化重排过程。**获取布局信息的操作会导致队列刷新**，比如一下方法：

- offsetTop、offsetLeft、offsetWidth、offsetHeight
- scrollTop、scrollLeft、scrollWidth、scrollHeight
- clientTop、clientLeft、clientWidth、clientHeight
- getComputedStyle( ) 

以上属性和方法需要返回最新的布局信息，因此浏览器不得不执行渲染队列中的**待处理变化**并触发重排以返回争取的值。

在修改样式的过程中，**最好避开使用上边的属性**，它们都会刷新渲染队列，触发重排和重绘



#### 最小化重绘和重排

##### 改变样式

- 合并多次对 DOM 和样式的修改，然后一次处理掉
  - 使用`cssText`属性
  - 使用 **class名** 而不是内联样式

##### 批量修改 DOM

- 当需要对 DOM 元素进行一系列操作时，可以通过一下步骤来减少重排和重绘

  1. 使元素脱离文档流
     - 隐藏元素、应用修改、重新显示
     - 使用文档片段（document fragment）在当前 DOM 之外构建一个子树，再把他拷贝回文档（推荐）
     - 将原始元素拷贝到一个脱离文档流的节点中，修改副本，完成后再替换原始元素
  2. 对齐应用多重改变
  3. 把元素带回文档中

  该过程会触发两次重排（1，3），如果忽略这两个步骤，那么在 2 中的任何一次修改都会触发一次重排

##### 缓存布局信息

将需要多次使用的布局信息缓存在一个变量中

#### 让元素脱离动画流

当页面顶部的一个动画推移页面整个余下的部分时，会导致一次代价昂贵的大规模重排，让用户感到页面一顿一顿的，使用以下步骤可以避免页面中的大部分重排：

1. 使用绝对位置定位页面上的动画元素，使其脱离文档流
2. 让元素动起来。当它扩大时，会临时覆盖部分页面。但这只是页面一个小区域的重绘过程，不会产生重排并重绘页面的大部分内容
3. 当动画结束时恢复定位，从而只会下移一次文档的其他元素



### 事件委托

事件逐层冒泡并能被父元素捕获。使用事件代理，只需给外层元素绑定一个处理器，就可以处理在其子元素上触发的所有事件。

根据 DOM 标准，每个事件要经历三个阶段：

- 捕获
- 到达目标
- 冒泡

