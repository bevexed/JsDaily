# JavaScript的加载和执行

- 多数浏览器使用单一进程来处理用户界面（UI）刷新 和  JavaScript 脚本执行，所以同一时刻只能作一件事。
- JavaScript 执行时间越久，浏览器响应时间越长。
- 在 JavaScript 加载的过程中，页面渲染和用户交互完全是阻塞的

- 每次遇到  \<script> 标签，页面必须停下来等待文件加载并执行



## 脚本位置（将脚本放在底部）

- HTML4 规范指出 \<script> 标签可以放在 HTML文档的 \<head> 或 \<body> 中
- 理论上说，把与样式和行为有关的脚本放在一起，并先加载它们，这样做有助于保证页面的渲染和交互的正确性。
- 不要将 \<script> 标签放在**页面顶部**，因为
  - 浏览器在 解析 \<body> 标签之前，不会渲染页面的任何部分。
  - 每个文件必须等 **上一个JavaScript文件**下载完毕并执行完成才会开始下载下一个文件（现在的浏览器可以并行下载JavaScript文件，但仍会阻塞其他资源的下载，比如图片）
  - 因为脚本阻塞其他页面资源的下载，所以推荐将所有的 \<script> 标签尽可能的放到 \<body> 标签的“**底部**



## 组织脚本（合并脚本）

- 由于每个 \<script> 标签初始下载是都会阻塞页面渲染，所以**减少**页面的 \<script> 标签数量可以改善这个状况
- 这不仅仅针对**外链脚本**，**内嵌脚本**的数量同样也要限制
- 把一段**内嵌脚本**放在 \<link> 标签后，会导致页面阻塞去等待样式表的下载，所以不要内嵌脚本紧跟在 \<link> 后
- 由于 http 有**性能**损耗，所以**减少**页面中**外连脚本文件**数量将会改善性能、



## 无阻塞脚本（window.onload）

- JavaScript 倾向于阻止浏览器的某些处理过程，如 HTTP 请求和用户界面更新
- 减少 JavaScript 文件大小并限制 HTTP 请求次数并不总是能解决问题
  - Web 应用的功能越来越丰富，所需要的 JavaScript 文件只产生一次 HTTP 请求，却会锁死浏览器一大段时间
  - 为了避免这种情况，需要向页面**逐步**加载 JavaScript 文件
- 无阻塞的秘诀在于，在页面加载完成后才加载 JavaScript 代码。
  - 在 window 对象的 load 事件触发后在下载脚本
  - 通过 \<script> 标签的 defer 属性
  - HTML5 的 async 属性
    - async 和 defer 的**相同特点**是采用并行下载，在下载过程中不会产生阻塞
    - **区别**在于 async 加载后自动执行，defer需要通过页面加载后执行



## 延迟脚本（defer）

- HTML4 为 \<script> 标签定义的新属性 defer
- defer 属性指明本元素所含的脚本**不会修改DOM**，因此代码能够安全地延迟执行
- **不是一个理想的跨浏览器解决方案**
- 在支持 defer 的浏览器上：defer 在 onload 之前执行



## 动态脚本元素（DOM创建\<script>）

- 由于文档对象模型（DOM）的存在，你可以用 JavaScript 动态的创建 \<script> 标签
- \<script> 元素接收完成时会触发一个 load 事件，用于监听脚本加载状态



## XMLHttpRequest脚本注入

- 通过 XHR 对象获取脚本并注入到页面中
  - 通过创建一个 XHR 对象
  - 然后用他下载 JavaScript 文件
  - 最后通过动态 \<script> 元素注入到页面中
- 优点
  - 可以提前下载  JavaScript 代码
  - 处于文档之外不会自动执行，需要的用到时候在引入到文档内执行
  - 在所有的组六浏览器中都能正常执行
- 缺点
  - JavaScript 文件必须和所请求的页面处于相同的域，这意味着 JavaScript 不能通过 CDN 下载
  - 所以大型 Web 应用通常不会采用这中技术