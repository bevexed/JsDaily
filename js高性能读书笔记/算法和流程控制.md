# 算法和流程控制

代码的整体结构是影响速度的主要因素之一。代码数量少并不意味着运行速度就快，代码数量多也不意味着运行速度一定慢。代码的组织结构和解决问题的思路是影响代码性能的主要因素。



## 循环

在大多数编程语言中，代码执行时间大部分消耗在循环中。理解 JavaScript 中循环对性能的影响至关重要，因为死循环或长时间运行的循环会严重影响用户体验。



### 循环的类型

- for 循环是 JavaScript 中最常见的循环结构。
  - 由四部分组成：初始化、前测条件、后执行体、循环体
  - 当代码运行到 for 循环时，先运行初始化代码，然后进入前测条件，如果前测条件的结果为 true，则运行循环体。
  - 循环体执行完后，后执行代码开始运行

> 在 for 循环初始化中的 var 语句会创建一个函数级的变量，而不是循环级。由于 JavaScript 只有函数级作用域，因此在 for 循环中定义一个新变量相当于在循环体外定义一个新变量。

- while 循环是最简单的前测循环
  - 由一个前测条件和一个循环体构成
  - 再循环体运行前，先计算前测条件，如果计算结果为 true，就运行循环体。否则循环体就会被跳过
  - 任何 for 循环都能改写成 while 循环，反之亦然
- do-while 循环是 JavaScript 中唯一一种后测循环。
  - 由循环体和后测条件构成
  - 在 do-while 循环中，循环体至少运行一次，然后再由后测条件决定是否再次运行
- for-in 循环可以枚举任何对象的属性名。
  - 所返回的属性包括对象实例属性以及从原型链中继承而来的属性

### 循环性能

只有 for-in 循环比其几种明显要慢，由于每次迭代操作都会同时搜索实例和原型属性，for-in 循环的每次迭代都会产生更多开销，所以比其他循环类型慢。

- 不要使用 for-in 来遍历数组成员

- 循环类型的选择应该基于**需求**而不是**性能**

- 如果需要遍历一个数量有限的已知属性列表，使用其他循环会更快。

  ```javascript
  const props = ['prop1','prop2'];
  let i = 0;
  while(i < props.length){
    process(object[props[i++]]);
  }
  ```

- 当循环类型与性能无关时，有两个可选因素（每次迭代处理的事务、迭代次数），只要减少两者中的一个或全部的时间开销，就能提升循环的整体性能。

#### 减少迭代工作量

提升循环性能整体速度的好方法是

- 限制循环中耗时操作的数量

- 减少对象成员及数组项的查找次数

- 通过颠倒数组的顺序来提高循环性能

  > 倒序循环是编程语言中一种通用的性能优化方法，但一般来说并不是那么容易理解。

  ```javascript
  // 减少属性查找次数并反转
  const arr = [1,2,3,4,5]
  for (let i = arr.length;i--;){
    console.log(i)
  }
  ```

  

#### 减少迭代次数

即使是循环体中执行最快的代码，累计迭代（循环体运行时会带来依次小的性能开销）上千次也会变慢下来。

最广为人知的一种限制循环迭代次数的模式被称为"达夫设备（Duff's Device）"

"Duff‘s Device" 是一个循环体展开技术，它使得一次迭代中实际执行了多次迭代的操作。

```javascript
let iterations = Math.floor(items.length / 8),
    startAt = item.length % 8,
    i = 0;
do {
  switch(startAt){
    case 0 : process(items[i++]);
    case 1 : process(items[i++]);
    case 2 : process(items[i++]);
    case 3 : process(items[i++]);
    case 4 : process(items[i++]);
    case 5 : process(items[i++]);
    case 6 : process(items[i++]);
    case 7 : process(items[i++]);
  }
} while(--iterations)
```

> 推荐迭代次数大于 1000 次时使用



### 基于函数的迭代

尽管基于函数的迭代提供了一个更为便利的迭代方法，但它仍比基于循环的迭代要慢一些。

- 对每个数组项调用外部方法带来的开销是速度慢的主要原因
- 在所有情况下，基于循环的迭代比基于函数的迭代快 8 倍，因此在运行速度要求严格时，基于函数的迭代不是合适的选择



## 条件语句

与循环的原理类似，条件表达式决定了 JavaScript 运行流的走向

### if-else 对比 switch

- 条件数量越大，越倾向于使用 switch 而不是 if-else。（这通常归结于代码的易读性）
- 大多数情况下 switch 比 if-else 运行得要快
- if-else 适用于判断两个离散值或几个不同的值域
- 当判断多余两个离散值时，switch 语句是更加选择

### 优化 if-else

优化 if-else 的目标是：最小化到达正确分支所需判断的条件数量。

- 确保最可能出现的条件放在首部（条件语句总是按照从最大概率到最小概率的顺序排序）
- 把 if-else 组织成一系列嵌套的 if-else 语句 
  - 二分法原理
  - 适用于多个值域需要测试的时候
  - 如果是离散值，switch 语句更为合适

### 查找表

有些时候优化条件语句的最佳方案是避免使用 if-else 和 switch ，取而代之的是使用**查找表**

- 当有大量离散值需要测试时，if-else 和 switch 比使用查找表慢很多。
- JavaScript 中可以使用数组和普通对象构建查找表
- 当使用查找表时，必须完全抛弃条件判断语句。
  - 不用写任何条件判断语句，即便候选值数量增加时，也几乎不会产生额外的性能开销。
- 使用查找表相对于 if-else 和 switch ，不仅速度快，而且有时代码的可读性更好
  - 当需要测试的离散值数量非常大的时候，switch 语句将会变的很笨重
  - 当单个键和单个值之间存在逻辑映射时，查找表是最佳选择
  - switch 语句更适合每个键都需要对应一个独特的动作或一系列动作的场合

## 递归

使用递归可以把复杂的算法变简单。

但是递归函数的潜在问题是

- 终止条件不明确或缺少终止条件会导致函数长时间运行，并使用户界面处于假死状态
- 递归函数还可能遇到浏览器的“调用栈大小限制”（Call stack size limites）

### 调用栈限制

- JavaScript 引擎支持的递归数量与 JavaScript 调用栈大小直接相关。

- 可以使用 try-catch 表达式捕获调用栈溢出错误

  > 尽管在 JavaScript 中调用栈溢出错误可以捕获，但不推荐这样做

### 递归模式

当遇到调用栈大小限制时，应该先检查代码中的递归实例，有两种模式值得注意。

- 直接递归（函数调用自身）
- 隐伏模式（两个函数互相调用，形成一个无限循环）

大多数栈错误都与这两种模式有关。最常见的栈溢出原因是不正确的终止条件，因此

- 定位错误模式的第一步是验证终止条件。
  - 如果终止条件没问题，那么可能是算法包含了太多的递归
  - 建议改用迭代、Memoization，或结合两者解决问题

### 迭代

任何递归能实现的方法都可以使用迭代来实现。

- 迭代算法通常包含几个不同的循环，分别对应计算过程中的不同方面，这也会引入一些性能问题
- 优化后的循环替代长时间运行的递归函数可以提升性能
- 运行一个循环比反复调用一个函数的开销要小的多

### Memoization

> 减少工作量是最好的性能优化技术。

Memoization 缓存前一个计算结果供后续计算使用，避免了重复的工作。

```javascript
function memoize(fundamental, cache){
	cache = cache || {};
  const shell = function(arg){
		if(!cache.hasOwnProperty(arg)){
      cache[arg] = fundamental(arg);
    }
    return cache[arg];
  }
  return shell;
}
```



