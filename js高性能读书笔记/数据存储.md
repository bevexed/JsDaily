## 数据存储

计算机科学中的一个经典问题是通过改变数据的存储位置来获取最佳的读写性能，数据**存储位置**关系到代码执行过程中的数据**检索速度**。

每一种数据存储的位置都有不同的读写速度。

JavaScript 中有四种基本数据存储位置

- 字面量：
  - 字面量只代表自身，不存储在特定位置。
  - JavaScript中的字面量有：字符串、数字、布尔值、对象、数组、函数、正则表达式、undefined 和 null
- 本地变量：
  - 开发人员使用 **var** 关键字定义的数据存储单位
- 数组元素
  - 存储在 JavaScript 数组对象内部，以**数字**作为索引
- 对象成员
  - 存储在 JavaScript 对象内部，以**字符串**作为索引

大多数情况下，从一个字面量和一个局部变量中存取数据的性能差异是微不足道的。访问数组元素和对象成员的代价要高一些

> **尽量使用字面量和局部变量，减少数组项和对象成员的使用**



### 管理作用域

作用域概念是理解 JavaScript 的关键所在，不仅仅从性能角度，还包括从功能角度。

- 作用域对 JavaScript 有很多影响，从确定哪些变量可以呗函数访问，到确定 this 的赋值
- JavaScript 作用域同样关系到性能



### 作用域和标识符解析

- 每一个 JavaScript 函数都表示为一个对象，更确切的说是 Function 对象的一个实例

- Function 对象同其他对象一样，拥有可以编程访问的属性，和一系列不能通过代码访问而仅供 JavaScript 引擎存取的内部属性，其中有一个属性是 [[Scope]]，内部属性 [[Scope]] 包含了一个函数被创建的作用域中对象的**集合**

  - 这个集合被称为元素的作用域链，他决定哪些数据能被函数访问
  - 函数作用域中的每个对象被称为一个可变对象
  - 每个可变对象都以**“键值对”**的形式存在
  - 当一个函数**创建**后，它的作用域链会被创建此函数的作用域中可访问的数据对象所填充

- 函数**执行**时会创建一个**执行环境（执行上下文）**的内部对象

  - 一个执行环境定义了一个函数执行时的环境
  - 函数每次执行时对应的执行环境都是**独一无二**的，所以多次调用同一个函数就会导致创建多个执行环境
  - 函数执行完毕后，执行环境就被销毁
  - 每个执行环境都有自己的作用域链，用于解析标识符
  - 当执行环境被创建时，它的作用域链初始为当前运行函数的[[Scope]]属性中的对象。
  - 这些值按照它们出现在函数中的顺序，被复制到执行环境的作用域链中

- 以上过程一旦完成会创建一个**活动对象**

  - 活动对象作为函数运行时的**变量对象**
  - 包涵所有局部变量、命名参数、参数集合以及 this
  - 此活动对象被推入作用域链的最前端

- 当执行环境被销毁，活动对象也随之销毁

- 在函数执行过程中，每遇到一个变量，都会经历一次标识符解析过程以及决定从哪里获取或存储数据

  - 该过程搜索执行环境的作用域链，查找同名标识符。

  - 搜索过程从作用域链头部开始，也就是当前运行函数的活动对象

  - 如果找到，就是用这个标识符对应的变量，如果没找到，就继续作用域链中的下一个对象

  - 若无法搜索到匹配的对象，那么标识符将被视为未定义

    

### 标识符解析的性能

- 在执行环境中的作用域链中，一个标识符所在的位置越深，他的读写速度也就越慢
- 全局变量总是存在于执行环境作用域链的最末端
- 函数中读取局部变量总是最快的，读写全局变量是最慢的
- 如果某个跨作用域的值在函数内被引用一次以上，那么就把他存储到局部变量里



### 改变作用域链

- 一般来说，一个执行环境的作用域链是不会改变的，但是有两个语句可以临时改变作用域链
  - with：当使用 with 语句时，执行环境的作用域链临时改变了。一个新的变量对象被创建，它包含了参数指定的对象的所有属性。这个对象被推入作用域链的首部，这意味着函数的所有局部变量现在处于第二个作用域链对象中，因此访问的代价更高了
  - try-catch：当 try 代码块中的语句发生错误时，执行过程会自动跳转到 catch 子句，然后把异常对象推入一个变量对象并置于作用域首部。在 catch 代码块中，函数内部的所有变量将会放在第二个作用域链对象中。一旦 catch 子句执行完毕，作用域链就会返回到之前的状态

> try-catch 语句不应该被用来解决 JavaScript 错误，如果你知道某个错误经常出现，那说明时代码本身的问题



###动态作用域

- **with 语句**、try-catch 的 **catch 子句**和 包含 **eval()**的函数，都被认为是动态作用域
- 动态作用域只存在于代码执行过中，因此无法通过静态分析（查看代码结构）检测出来
- 只有必要的时候才推荐使用动态作用域



### 闭包、作用域和内存

闭包是 JavaScript 最强大的特性之一 

- 允许函数访问局部作用域之外的数据
- 使用闭包可能导致性能问题



### 对象成员

- 大部分 JavaScript 代码都是以面向对象风格编写的，这会导致非常频繁地访问对象成员

- 对象成员包括**属性**和**方法**



### 原型

JavaScript 中的对象是基于**原型**的

- 原型是其他对象的基础，它定义并实现了一个新创建的对象所必须包含的成员列表
- 原型对象为所有对象实例所共享
- 对象通过一个内部对象绑定到其他成员
- 对象有两种成员类型：
  - **实例成员**：直接存在于对象实例中 
  - **原型成员**：从对象原型继承而来



### 原型链

对象的原型决定了实例的类型

- 默认情况下，所有对象都是**对象（Object）**的实例，并继承了所有基本方法
- 搜索实例成员比从**字面量**或**局部变量中**读取数据代价更高



### 嵌套成员

对象嵌套越深读取速度越慢（location.href 总是比 window.location.href 要快）



### 缓存对象成员值

- 由于所有类似的性能问题都与对象成员有关，因此应尽可能的避免使用它们。
- 在同一函数中没必要多次读取同一个对象成员
- 多次使用的变量应该缓存为局部变量